<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Roboto', sans-serif;
      background-color: white;
    }

    .center {
      margin: auto;
      width: 50%;
    }

    /* tooltip for lollipop hover */
    #custom-tooltip {
      position: absolute;
      display: none;
      pointer-events: none;
      background: rgba(255, 255, 255, 0.98);
      border: 1px solid rgba(0, 0, 0, 0.12);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
      padding: 8px 10px;
      border-radius: 6px;
      font-size: 13px;
      color: #111;
      z-index: 9999;
      max-width: 378px;
      margin: 2px;
    }

    .ct-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 6px
    }

    .ct-label {
      width: 64px;
      font-weight: 600;
      font-size: 12px
    }

    .ct-bar {
      flex: 1;
      height: 12px;
      background: #eee;
      overflow: hidden
    }

    .ct-bar-fill {
      height: 100%;
    }

    .ct-value {
      width: 50px;
      text-align: right;
      font-size: 12px
    }

    .ct-img {
      width: 64px;
      height: 96px;
      object-fit: cover;
      margin-right: 8px
    }

    .res-left {
      flex: 1;
      height: 12px;
      right: 0;
      background-color: #ff0000;
    }

    .res-right {
      flex: 1;
      height: 12px;
      left: 0;
      background-color: #0000ff;
    }

    .res-full {
      flex: 1;
      height: 12px
    }
  </style>
</head>

<body>
  <div class="center" id="regressionPlot" style="width:1224px;height:800px;"></div>
  <div id="custom-tooltip" aria-hidden="true"></div>
  <script>
    // Load JSON file
    fetch("Entrega 1/popularidad.json")
      .then(response => response.json())
      .then(data => {
        // Nota: hay que desactivar la cache en "Network" en DevTools para que recargue el JSON
        console.log(data);
        // Extract variables
        const labels = data.map(d => d.genero);
        const x = data.map(d => d.proporcion);
        const y = data.map(d => d.popularidad);
        const r = data.map(d => d.residuos);
        const a1 = data.map(d => d.anime_1);
        const a2 = data.map(d => d.anime_2);

        const minVal = Math.min(...r);
        const maxVal = Math.max(...r);
        // f^-1 de f(x) = min + x * (max - min)
        const zeroPos = (0 - minVal) / (maxVal - minVal);

        // --- Traces ---

        // Regression line
        const maxval = Math.max(...y);
        const lineX = [0, maxval];
        const lineY = lineX;

        const regressionLine = {
          x: lineX,
          y: lineY,
          mode: 'lines',
          type: 'scatter',
          name: 'Regression Line',
          line: { color: 'black', width: 1, dash: 'dash' },
          hovertemplate: '<extra></extra>'
        };

        // Residual lollipops (vertical segments)
        function colorScale(val, minVal, maxVal, zeroPos) {
          const t = (val - minVal) / (maxVal - minVal); // normalize 0..1
          if (t <= zeroPos) {
            // interpolate red → gray
            const alpha = t / zeroPos;
            return `rgb(${255 * (1 - alpha) + 128 * alpha},${0 + 128 * alpha},${0 + 128 * alpha})`;
          } else {
            // interpolate gray → blue
            const alpha = (t - zeroPos) / (1 - zeroPos);
            return `rgb(${128 * (1 - alpha)},${128 * (1 - alpha)},${128 + 127 * alpha})`;
          }
        }

        const points = x.map((d, i) => {
          return {
            x: [x[i]],
            y: [y[i]],
            mode: 'markers',
            type: 'scatter',
            name: 'Observed',
            marker: {
              size: 5 + Math.abs(r[i]) * 100 / 2,
              color: colorScale(r[i], minVal, maxVal, zeroPos)
            },
            showlegend: false,
            hovertemplate: '<extra></extra>'
          };
        });

        const bars = x.map((d, i) => {
          return {
            data: [x[i], y[i]],
            type: 'bar',
            backgroundColor: ['rgb(200,200,200)', 'rgb(150,150,150)'],
            showlegend: false,
            hovertemplate: '<extra></extra>',
            options: {
              indexAxis: 'y'
            }
          };
        });

        const scaleMax = Math.max(...x.concat(y));
        const residScale = Math.max(Math.abs(minVal), Math.abs(maxVal));

        const residualSegments = x.map((d, i) => {
          const genre = labels[i] || `Género ${i}`;
          const resid = r[i];
          const pct = (resid * 100).toFixed(2);
          const color = colorScale(resid, minVal, maxVal, zeroPos);
          // build candidate image paths (note: correct folder name has a space: 'Entrega 2')
          const image1 = `Entrega 2/anime_images/${genre}1.jpg`;
          const image2 = `Entrega 2/anime_images/${genre}2.jpg`;
          return {
            x: [x[i], x[i]],
            y: [y[i], x[i]], // start at actual y, end at fitted value
            mode: 'lines',
            type: 'scatter',
            line: { width: 2, color: color },
            showlegend: false,
            // suppress native tooltip but keep hover events
            hovertemplate: '<extra></extra>',
            customdata: { index: i, genre, oferta: x[i], demanda: y[i], resid: pct, residRaw: r[i], residScale, scaleMax, image1, image2 }
          };
        });

        const color_action = colorScale(r[0], minVal, maxVal, zeroPos);
        const color_kids = colorScale(r[5], minVal, maxVal, zeroPos);
        const color_harem = colorScale(r[6], minVal, maxVal, zeroPos);

        const action_label = `<b>Action</b> (<span style="color:${color_action};">+${r[0].toFixed(2) * 100}%</span>)`;
        const kids_label = `<b>Kids</b> (<span style="color:${color_kids};">${r[5].toFixed(2) * 100}%</span>)`;
        const harem_label = `<b>Harem</b> (<span style="color:${color_harem};">${r[6].toFixed(2) * 100}%</span>)`;

        const layout = {
          dragmode: false,            // <-- disable drag-to-zoom / drag-to-select
          hovermode: 'closest',
          xaxis: {
            showgrid: false,
            tickformat: ',.0%',
            range: [0, maxval + 0.01],
            tickvals: [0.05, 0.10, 0.15, 0.20, 0.25, 0.3],
            hovertemplate: '<extra></extra>'
          },
          yaxis: {
            showgrid: false,
            tickformat: ',.0%',
            range: [0, maxval + 0.01],
            tickvals: [0.05, 0.10, 0.15, 0.20, 0.25, 0.3],
            hovertemplate: '<extra></extra>'
          },
          annotations: [
            { // TITULO
              text: "Oferta versus Demanda en géneros de anime: ¿qué tan alineados están?",
              font: { size: 32, color: "black", family: "Roboto" },
              xref: 'paper',
              yref: 'paper',
              x: 0.5,
              y: 1.23,
              showarrow: false,
              xanchor: "center",
              yanchor: "bottom",
              hovertemplate: '<extra></extra>'
            },
            { // SUB-TITULO
              text: 'Action destaca por una demanda muy superior a su oferta,<br>\
mientras que Kids y Harem sobresalen por un exceso de oferta frente a su demanda.',
              xref: 'paper',
              yref: 'paper',
              x: 0.5,     // center horizontally
              y: 1.10,    // slightly below the title
              showarrow: false,
              xanchor: "center",
              yanchor: "bottom",
              font: { size: 20, color: 'black' }
            },
            { // ESQUINA SUPERIOR IZQUIERDA
              text: "Mayor demanda<br>que oferta",
              xref: "paper",
              yref: "paper",
              x: 0.79,   // near left
              y: 0.97,   // near top
              showarrow: false,
              font: { size: 24, color: "blue", family: "Roboto" }
            },
            { // ESQUINA INFERIOR DERECHA
              text: "Mayor oferta<br>que demanda<br> ",
              xref: "paper",
              yref: "paper",
              x: 0.97,   // near right
              y: 0.59,   // near bottom
              xanchor: "right",
              yanchor: "bottom",
              showarrow: false,
              font: { size: 24, color: "red", family: "Roboto" }
            },
            { // EJE Y
              text: "<b>Demanda de animes por género</b>",
              xref: "paper",
              yref: "paper",
              x: -0.105,
              y: 1.04,
              xanchor: "left",
              yanchor: "center",
              font: { family: "Roboto", size: 14, color: "rgb(10,10,10)" },
              showarrow: false,
            },
            { // EJE X
              text: "<b>Oferta de animes por género</b>",
              xref: "paper",
              yref: "paper",
              x: 0.5,
              y: -0.05,
              xanchor: "center",
              yanchor: "top",
              font: { family: "Roboto", size: 14, color: "rgb(10,10,10)" },
              showarrow: false,
            }, { // DIAGONAL
              x: 0.235,
              y: 0.247,
              text: "<b>Oferta = Demanda</b>",
              showarrow: false,
              textangle: -30,
              font: { size: 15 },
            },
            { // FLECHITA ACTION
              x: 0.160,               // the point you want to point to
              y: 0.332,
              xref: 'x',          // use 'x'/'y' for data coordinates
              yref: 'y',
              showarrow: true,    // enables the arrow
              arrowhead: 3,       // style of the arrow
              arrowsize: 1,       // size of the arrow
              ax: -90,             // x-offset of text relative to point
              ay: 0,            // y-offset of text relative to point
              text: action_label,  // label text
              font: {
                family: "Roboto",
                size: 25,
                color: "rgb(10,10,10)"
              },
              xanchor: "right",
              yanchor: "center",
              arrowcolor: 'black'
            }, { // FLECHITA KIDS  
              x: 0.145,               // the point you want to point to
              y: 0.0188,
              xref: 'x',          // use 'x'/'y' for data coordinates
              yref: 'y',
              showarrow: true,    // enables the arrow
              arrowhead: 3,       // style of the arrow
              arrowsize: 1,       // size of the arrow
              ax: -90,             // x-offset of text relative to point
              ay: -0,            // y-offset of text relative to point
              text: kids_label,  // label text
              font: {
                family: "Roboto",
                size: 25,
                color: "rgb(10,10,10)"
              },
              xanchor: "right",
              yanchor: "center",
              arrowcolor: 'black'
            }, { // FLECHITA HAREM
              x: 0.203,               // the point you want to point to
              y: 0.008,
              xref: 'x',          // use 'x'/'y' for data coordinates
              yref: 'y',
              showarrow: true,    // enables the arrow
              arrowhead: 3,       // style of the arrow
              arrowsize: 1,       // size of the arrow
              ax: 70,             // x-offset of text relative to point
              ay: -24,            // y-offset of text relative to point
              text: harem_label,  // label text
              font: {
                family: "Roboto",
                size: 25,
                color: "rgb(10,10,10)"
              },
              xanchor: "left",
              yanchor: "center",
              arrowcolor: 'black'
            },

          ],
          showlegend: false,
          margin: {
            l: 140,   // left
            r: 140,   // right
            t: 190,  // top (increase this!)
            b: 60    // bottom
          },
          images: [
            {
              source: "Entrega 1/img/goku.png", // PNG URL or base64
              xref: "x",
              yref: "y",
              x: 0.105,      // anchor x-coordinate
              y: 0.315,     // anchor y-coordinate
              sizex: 0.04,  // width in data units
              sizey: 0.2,  // height in data units
              sizing: "contain",  // "stretch", "contain", or "fill"
              opacity: 1,
              layer: "above"  // or "below"
            },
            {
              source: "Entrega 1/img/quint.png", // PNG URL or base64
              xref: "x",
              yref: "y",
              x: 0.225,      // anchor x-coordinate
              y: 0.181,     // anchor y-coordinate
              sizex: 0.0617,  // width in data units
              sizey: 0.3,  // height in data units
              sizing: "contain",  // "stretch", "contain", or "fill"
              opacity: 1,
              layer: "above"  // or "below"
            },
            {
              source: "Entrega 1/img/doraemon.png", // PNG URL or base64
              xref: "x",
              yref: "y",
              x: 0.11,      // anchor x-coordinate
              y: 0.11,     // anchor y-coordinate
              sizex: 0.035,  // width in data units
              sizey: 0.3,  // height in data units
              sizing: "contain",  // "stretch", "contain", or "fill"
              opacity: 1,
              layer: "above"  // or "below"
            }
          ]
        };

        // preserve original trace opacities (we'll use opacity-based highlighting)
        const nPoints = points.length;
        const originalPointSizes = points.map(p => (p.marker && p.marker.size) ? p.marker.size : 6);
        const originalPointColors = points.map(p => (p.marker && p.marker.color) ? p.marker.color : '#888');
        const originalResidualWidths = residualSegments.map(s => (s.line && typeof s.line.width === 'number') ? s.line.width : 2);
        const originalResidualColors = residualSegments.map(s => (s.line && s.line.color) ? s.line.color : '#888');
        const originalPointOpacities = points.map(p => (typeof p.opacity === 'number') ? p.opacity : 1);
        const originalResidualOpacities = residualSegments.map(s => (typeof s.opacity === 'number') ? s.opacity : 1);
        const pointTraceIndices = Array.from({ length: nPoints }, (_, i) => 1 + i);
        const residualTraceIndices = Array.from({ length: nPoints }, (_, i) => 1 + nPoints + i);
        const config = {
          displayModeBar: false,
          responsive: true,
          displaylogo: false,
          scrollZoom: false,
          doubleClick: false,
          modeBarButtonsToRemove: [
            'zoom2d', 'pan2d', 'select2d', 'lasso2d',
            'zoomIn2d', 'zoomOut2d', 'autoScale2d', 'resetScale2d',
            'hoverClosestCartesian', 'hoverCompareCartesian'
          ]
        };

        Plotly.newPlot('regressionPlot', [regressionLine, ...points, ...residualSegments], layout, config).then(gd => {

          const tooltip = document.getElementById('custom-tooltip');
          let currentHighlight = { pointIdx: null, residIdx: null };
          function restoreHighlight() {
            // restore opacities for all point traces
            try {
              for (let i = 0; i < pointTraceIndices.length; i++) {
                const tid = pointTraceIndices[i];
                const orig = (i < originalPointOpacities.length) ? originalPointOpacities[i] : 1;
                Plotly.restyle(gd, { 'opacity': orig }, [tid]);
              }
              for (let i = 0; i < residualTraceIndices.length; i++) {
                const tid = residualTraceIndices[i];
                const orig = (i < originalResidualOpacities.length) ? originalResidualOpacities[i] : 1;
                Plotly.restyle(gd, { 'opacity': orig }, [tid]);
              }
            } catch (e) {
              console.warn('restoreHighlight failed', e);
            }
            currentHighlight = { pointIdx: null, residIdx: null };
          }
          function pct(v) { return (Number.isFinite(v) ? (v * 100).toFixed(2) + '%' : 'N/A'); }
          function renderBars(oferta, demanda, scaleMax) {
            const o = Number(oferta);
            const d = Number(demanda);
            const scale = (Number.isFinite(scaleMax) && scaleMax > 0) ? scaleMax : Math.max(Math.abs(o), Math.abs(d), 0.0001);
            const oW = Number.isFinite(o) ? Math.max(6, (o / scale) * 100) : 6;
            const dW = Number.isFinite(d) ? Math.max(6, (d / scale) * 100) : 6;
            return `
              <div class="ct-row"><div class="ct-label">Oferta</div>
                <div class="ct-bar"><div class="ct-bar-fill" style="width:${oW / 2}%;background:#ff0000"></div></div>
                <div class="ct-value">${pct(o)}</div>
              </div>
              <div class="ct-row"><div class="ct-label">Demanda</div>
                <div class="ct-bar"><div class="ct-bar-fill" style="width:${dW / 2}%;background:#0000ff"></div></div>
                <div class="ct-value">${pct(d)}</div>
              </div>
            `;
          }

          gd.on('plotly_hover', ev => {
            console.log(">--");
            console.log(ev.points);
            console.log(">--")
            if (!ev.points || ev.points.length === 0) return;
            const pt = ev.points.find(p => p.fullData && p.data.customdata);
            if (!pt) return;
            const cd = pt.data.customdata;
            // debug helper: log the customdata and point
            console.log('plotly_hover customdata:', cd, 'point:', pt);

            // highlight corresponding point and residual line
            // compute trace indices: regressionLine is at 0, points start at 1, residuals start at 1 + nPoints
            const pointTraceIndex = 1 + cd.index; // trace index for the marker trace
            const residualTraceIndex = 1 + nPoints + cd.index; // trace index for the residual line
            try {
              // restore any previous highlight first
              restoreHighlight();
              // dim all point and residual traces
              const lowOpacity = 0.18;
              try {
                Plotly.restyle(gd, { 'opacity': lowOpacity }, pointTraceIndices);
                Plotly.restyle(gd, { 'opacity': lowOpacity }, residualTraceIndices);
              } catch (e) {
                // fallback: iterate individually if batch restyle fails
                pointTraceIndices.forEach(t => Plotly.restyle(gd, { 'opacity': lowOpacity }, [t]));
                residualTraceIndices.forEach(t => Plotly.restyle(gd, { 'opacity': lowOpacity }, [t]));
              }
              // set hovered traces to full opacity
              Plotly.restyle(gd, { 'opacity': 1 }, [pointTraceIndex]);
              Plotly.restyle(gd, { 'opacity': 1 }, [residualTraceIndex]);
              currentHighlight = { pointIdx: pointTraceIndex, residIdx: residualTraceIndex };
            } catch (e) {
              console.warn('Highlight (opacity) failed', e);
            }

            // fallback: if customdata is missing oferta/demanda, use pt.x/pt.y
            const ofertaVal = (typeof cd.oferta === 'number') ? cd.oferta : (typeof pt.x === 'number' ? pt.x : (cd.oferta || 0));
            const demandaVal = (typeof cd.demanda === 'number') ? cd.demanda : (typeof pt.y === 'number' ? pt.y : (cd.demanda || 0));
            const scale = (cd && cd.scaleMax) ? cd.scaleMax : Math.max(ofertaVal, demandaVal, 0.0001);
            const residualSide = (cd.resid >= 0) ? "l" : "r";
            const residualValue = Math.abs(cd.resid);

            const imgHtml = cd.image1 ? `<img src="${cd.image1}" class="ct-img" onerror="this.style.display='none';console.warn('img load failed', this.src)"/>` : '';
            const imgHtml2 = cd.image2 ? `<img src="${cd.image2}" class="ct-img" onerror="this.style.display='none';console.warn('img load failed', this.src)"/>` : '';
            const anime1 = a1[cd.index];
            const anime2 = a2[cd.index];
            // compute numeric residual values
            const residValNum = Number.isFinite(Number(cd.residRaw)) ? Number(cd.residRaw) : 0;
            const residMaxNum = (cd && cd.residScale) ? Math.abs(cd.residScale) : Math.max(Math.abs(residValNum), 0.0001);
            const residRatio = Math.min(1, Math.abs(residValNum) / residMaxNum);
            // percent width relative to half the bar (center to edge -> 50%)
            const residPercent = Math.max(0, Math.min(50, residRatio * 50));
            const residPctText = Number.isFinite(residValNum) ? (residValNum * 100).toFixed(2) + '%' : 'N/A';

            const residBarHtml = `
              <div style="margin-top:8px">
                <div style="font-weight:600;margin-bottom:6px;text-align:center">Residuo</div>
                <div style="position:relative;height:14px;background:#eee;overflow:hidden">
                  <div style="position:absolute;left:50%;top:0;bottom:0;width:1px;background:#bbb;transform:translateX(-0.5px)"></div>
                  ${residValNum >= 0 ? `<div style="position:absolute;left:50%;top:0;height:100%;width:${residPercent}%;background:#0000ff"></div>` : `<div style="position:absolute;left:${50 - residPercent}%;top:0;height:100%;width:${residPercent}%;background:#de2d26"></div>`}
                </div>
                <div style="text-align:center;font-size:12px;color:#444;margin-top:6px">${residPctText}</div>
              </div>
            `;

            tooltip.innerHTML = `
            <div style="font-size:16px;font-weight:800;margin-bottom:8px;text-align:center">${cd.genre}</div>
            <div style="display:flex;align-items:flex-start;gap:12px">
              <div style="flex:1;min-width:180px">
                ` + renderBars(ofertaVal, demandaVal, scale) + `
                ${residBarHtml}
              </div>
              <div style="display:flex;flex-direction:column;align-items:center;gap:6px;min-width:88px">
                ${imgHtml}
                <div style="font-size:12px;text-align:center;max-width:84px;word-break:break-word">${anime1 || ''}</div>
              </div>
              <div style="display:flex;flex-direction:column;align-items:center;gap:6px;min-width:88px">
                ${imgHtml2}
                <div style="font-size:12px;text-align:center;max-width:88px;word-break:break-word">${anime2 || ''}</div>
              </div>
            </div>
            `;
            tooltip.style.display = 'block';
            tooltip.style.left = (ev.event.clientX + 12) + 'px';
            tooltip.style.top = (ev.event.clientY + 12) + 'px';
          });

          gd.on('plotly_unhover', ev => {
            tooltip.style.display = 'none';
            tooltip.innerHTML = '';
            // restore highlighted styles
            try { restoreHighlight(); } catch (e) { console.warn('Restore highlight failed', e); }
          });
        });
      })
      .catch(err => console.error("Error loading JSON:", err));
  </script>
</body>

</html>